# Задание
1) Реализовать клиент-сервер схему "Простой параллелльный сервер"
2) Реализовать клиент-сервер схему "Параллелльный сервер с пулом"
3) Реализовать клиент-сервер схему "Потребитель-производитель"
4) Реализовать клиент-сервер схему мультипротокольного сервера (через epoll в одном потоке с двуся сокетами)

# Схемы

## Схема 1 (Простой параллельный сервер)
Процесс порождает 3 вида потоков:
- Слушающий поток
- Обслуживающий поток
- Поток-сборщик

### Списки
Для реализации возможности запускать несколько слушающих и обслуживающих потоков используются двусвязные списки. 
Всего есть два списка
- Список слушающих потоков
- Список обслуживающих потоков

Списки логически подразделяются на следующие виды 
- Список живых слушающих потоков
- Список мёртвых слушающих потоков
- Список живых обслуживающих потоков
- Список мёртвых обслуживающих потоков

### Слушающий поток
Принимает списки 
- Список живых слушающих потоков
- Список мёртвых слушающих потоков
- Список живых обслуживающих потоков
- Список мёртвых обслуживающих потоков

Поток сам добавляет и удаляет себя списоков живых и мёртвых слушающих потоков (Лучше так, потому что в узле содержится tid потока)

Создаёт сокет из переданного endpoint'a, биндится, постоянно ждёт соединения, при соединении создаёт обслуживающий сокет с тем же адресом и автоматически выбранным портом, передаёт клиенту новый endpoint, создаёт обслуживающий поток с этим endpoint'ом и снова начинает слушать.

### Обслуживающий поток
Принимает списки 
- Список живых слушающих потоков
- Список мёртвых слушающих потоков

Поток сам добавляет и удаляет себя списоков живых и мёртвых слушающих потоков (Лучше так, потому что в узле содержится tid потока)

Ждёт соединения от клиента. Отправляет текущее время и завершается.

### Поток-сборщик

Принимает массив указателей на списки 
- Список живых слушающих потоков
- Список мёртвых слушающих потоков
- Список живых обслуживающих потоков
- Список мёртвых обслуживающих потоков

Просыпается раз в секунду и забирает статусы мёртвых потоков, освобождает некоторые неосвобождённые ресурсы потоков.

### Завершение потоков
На сервере изменена переопределена диспозиция сигнала SIGUSR1 на пустую.
При принудительном заверщении живых слушающих и обслуживающих потоков происходит 2 действия
- Выставляется флаг завершения потока
- Потоку посылается сигнал SIGUSR1 для прерывания блокирующей функции (Завершение из-за прерывания обработано)
Поток заверщается

При принудительном заверщении потока-сборщика просто выставляется флаг завершения потока

### Замеки
- Для завершения сервера требуется ввести любой символ в stdin
- Подтверждения отправки данных перед закрытием сокета нет!!!!
- Утечек памяти нет
- Отслеживания выполенния на сервере нет

- Списки слушающих и обслуживающих потоков внутри между собой почти не связаны, однако, снаружи их можно логически связать и получить небольшую информацию о них
- Поток-сборжик может работать для нескольких списков одновременно, так что этот поток может быть всего один, или несколько.



## Схема 2 (Простой параллельный сервер с пулом)
Процесс порождает 2 вида потоков:
- Слушающий поток
- Обслуживающий поток

### Списки и пулы
Для реализации возможности отслеживать и контролировать несколько обслуживающих потоков в одном пуле потоков создан двусвязный список, который логически разделён на 3 списка 
- Список готовых обслуживающих потоков (ждут сигнала, чтобы проснуться)
- Список активных обслуживающих потоков (ждут соединения с клиентом или уже работают с ним)
- Список мёртвых обслуживающих потоков (в нём лежат завершённые потоки, чтобы забрать их статус и освободить ресурсы)

### Слушающий поток
Принимает endpoint и пул обслуживающих потоков
Создаёт сокет из переданного endpoint'a, биндится, постоянно ждёт соединения, при соединении выбирает первый готовый (спящий) поток, передаёт клиенту новый endpoint и снова начинает слушать.


### Обслуживающий поток
Принимает списки 
- Список готовых обслуживающих потоков
- Список активных обслуживающих потоков
- Список мёртвых обслуживающих потоков
Поток сам добавляет и удаляет себя списоков готовых, живых, мёртвых потоков

При пробуждении (переходе в активный список) начинает слушать свой порт. При присоединении клиента отправляет текущее время, разрывает соеденение и переходит в список готовых потоков.

### Завершение потоков
Обслуживающие потоки завершаются по установлению флага завершения и сигналу SIGUSR1. Сами добавляют себя в список мёртвых потоков (Забирать их статус и освобождать ресурсы нужно извне).
Слушающие потоки завершаются также, как обслуживающие (Забирать их статус и освобождать ресурсы нужно извне)

### Замеки
- Для завершения сервера требуется ввести любой символ в stdin
- Подтверждения отправки данных перед закрытием сокета нет!!!!
- Утечек памяти нет
- Отслеживание выполенния есть

- Потока-сборщика, забирающего статусы мёртвых потоков нет, всё вручную (не сделал, потому что устал)
- Нужно написать поток-реаниматор, который бы пересоздавал аварийно-завершённые потоки в пуле (не сделал, потому что устал)

## Схема 3
Даже описывать стыдно. Но работает.

## Схема 3 мультипротокольная
Даже описывать стыдно. Но работает.
